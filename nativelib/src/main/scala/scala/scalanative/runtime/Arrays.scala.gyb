package scala.scalanative
package runtime

// Note 1:
// Arrays.scala is currently implemented using textual templating that is
// expanded through project/gyb.py script. After every update Arrays.scala.gyb
// one has to re-generate the source via:
//
// $ ./project/gyb.py \
//     nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala.gyb > \
//     nativelib/src/main/scala/scala/scalanative/runtime/Arrays.scala

// Note 2:
// Arrays of primitive types don't contain pointers, runtime.allocAtomic() is
// called for memory allocation. Array of objects do contain pointers.
// runtime.alloc() is called for memory allocation.

import scalanative.native._
import scalanative.runtime.Intrinsics._
import scala.annotation.unchecked.uncheckedStable

sealed abstract class Array[T]
    extends java.io.Serializable
    with java.lang.Cloneable {
  import Array._

  /** Number of elements of the array. */
  @inline def length: Int =
    this.cast[Ptr[Array.Layout]].length

  /** Size between elements in the array. */
  def stride: CSize

  /** Pointer to the element. */
  def at(i: Int): Ptr[T]

  /** Loads element at i, throws IndexOutOfBoundsException. */
  def apply(i: Int): T

  /** Stores value to element i, throws IndexOutOfBoundsException. */
  def update(i: Int, value: T): Unit

  /** Create a shallow of given array. */
  protected override def clone(): Array[T] = ??? // overriden in concrete classes
}

object Array {
  type Layout = (Ptr[Info], Int)

  implicit class LayoutOps(val ptr: Ptr[Layout]) extends AnyVal {
    def info: Ptr[Info] = !ptr._1
    def length: Int     = !ptr._2
  }

  def copy(from: AnyRef, fromPos: Int,
           to: AnyRef, toPos: Int, len: Int): Unit = {
    if (from == null || to == null) {
      throw new NullPointerException()
    } else if (!from.isInstanceOf[Array[_]]) {
      throw new IllegalArgumentException("from argument must be an array")
    } else if (!to.isInstanceOf[Array[_]]) {
      throw new IllegalArgumentException("to argument must be an array")
    } else {
      copy(from.asInstanceOf[Array[_]], fromPos,
           to.asInstanceOf[Array[_]], toPos, len)
    }
  }

  def copy(from: Array[_], fromPos: Int,
           to: Array[_], toPos: Int, len: Int): Unit = {
    if (from == null || to == null) {
      throw new NullPointerException()
    } else if (getInfo(from) != getInfo(to)) {
      throw new ArrayStoreException("Invalid array copy.")
    } else if (len < 0) {
      throw new IndexOutOfBoundsException("length is negative")
    } else if (fromPos < 0 || fromPos + len > from.length) {
      throw new IndexOutOfBoundsException(fromPos.toString)
    } else if (toPos < 0 || toPos + len > to.length) {
      throw new IndexOutOfBoundsException(toPos.toString)
    } else if (len == 0) {
      ()
    } else {
      val fromPtr = from.at(fromPos).cast[Ptr[Byte]]
      val toPtr   = to.at(toPos).cast[Ptr[Byte]]

      `llvm.memmove.p0i8.p0i8.i64`(toPtr, fromPtr, to.stride * len, 1, false)
    }
  }
}

%{
  arrayInfos = ['Boolean', 'Char', 'Byte', 'Short',
                'Int', 'Long', 'Float', 'Double', 'Object']
}%
% for T in arrayInfos:

final class ${T}Array private () extends Array[${T}] {
  import ${T}Array._

  @inline def stride: CSize =
    sizeof[${T}]

  @inline def at(i: Int): Ptr[${T}] =
    if (i < 0 || i >= length)
      throw new IndexOutOfBoundsException(i.toString)
    else {
      this.cast[Ptr[Layout]].data + i
    }

  @inline def apply(i: Int): ${T} = !at(i)

  @inline def update(i: Int, value: ${T}): Unit = !at(i) = value

  @inline protected override def clone(): ${T}Array = {
    val size = sizeof[Array.Layout] + sizeof[${T}] * length
% if T != "Object":
    val arr = GC.malloc_atomic(size)
% else:
    val arr = GC.malloc(size)
% end
    `llvm.memcpy.p0i8.p0i8.i64`(arr, this.cast[Ptr[Byte]], size, 1, false)
    arr.cast[${T}Array]
  }
}

object ${T}Array {
  type Layout = (Ptr[Info], Int, ${T})

  implicit class LayoutOps(val ptr: Ptr[Layout]) extends AnyVal {
    def info: Ptr[Info]            = !ptr._1
    def info_=(v: Ptr[Info]): Unit = !ptr._1 = v
    def length: Int                = !ptr._2
    def length_=(v: Int): Unit     = !ptr._2 = v
    def data: Ptr[${T}]            = ptr._3
  }

  @inline def alloc(length: Int): ${T}Array = {
    val size = sizeof[Array.Layout] + sizeof[${T}] * length
    val arr  = {
% if T != "Object":
      val ptr = GC.malloc_atomic(size)
      `llvm.memset.p0i8.i64`(ptr, 0, size, 1, false)
      ptr
% else:
      val arr = GC.malloc(size)
% end
    }.cast[Ptr[Layout]]
    arr.info   = typeof[${T}Array]
    arr.length = length
    arr.cast[${T}Array]
  }
}

% end
